{"/home/travis/build/npmtest/node-npmtest-nock/test.js":"/* istanbul instrument in package npmtest_nock */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-nock/lib.npmtest_nock.js":"/* istanbul instrument in package npmtest_nock */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_nock = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_nock = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-nock/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-nock && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_nock */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_nock\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_nock.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_nock.rollup.js'] =\n            local.assetsDict['/assets.npmtest_nock.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_nock.__dirname +\n                    '/lib.npmtest_nock.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-nock/nock/index.js":"var recorder = require('./lib/recorder');\nmodule.exports = require('./lib/scope');\n\nmodule.exports.recorder = {\n    rec  : recorder.record\n  , clear   : recorder.clear\n  , play : recorder.outputs\n};\n\nmodule.exports.back = require('./lib/back');\nmodule.exports.restore = recorder.restore;\n","/home/travis/build/npmtest/node-npmtest-nock/nock/lib/recorder.js":"'use strict';\n\nvar inspect = require('util').inspect;\nvar parse = require('url').parse;\nvar common = require('./common');\nvar intercept = require('./intercept');\nvar debug = require('debug')('nock.recorder');\nvar _ = require('lodash');\nvar Stream = require('stream');\nvar URL = require('url');\n\nvar SEPARATOR = '\\n<<<<<<-- cut here -->>>>>>\\n';\nvar recordingInProgress = false;\nvar outputs = [];\n\nfunction getScope(options) {\n\n  common.normalizeRequestOptions(options);\n\n  var scope = [];\n  if (options._https_) {\n    scope.push('https://');\n  } else {\n    scope.push('http://');\n  }\n\n  scope.push(options.host);\n\n  //  If a non-standard port wasn't specified in options.host, include it from options.port.\n  if(options.host.indexOf(':') === -1 &&\n     options.port &&\n     ((options._https_ && options.port.toString() !== '443') ||\n       (!options._https_ && options.port.toString() !== '80'))) {\n    scope.push(':');\n    scope.push(options.port);\n  }\n\n  return scope.join('');\n\n}\n\nfunction getMethod(options) {\n\n  return (options.method || 'GET');\n\n}\n\nvar getBodyFromChunks = function(chunks, headers) {\n\n  //  If we have headers and there is content-encoding it means that\n  //  the body shouldn't be merged but instead persisted as an array\n  //  of hex strings so that the responses can be mocked one by one.\n  if(common.isContentEncoded(headers)) {\n    return _.map(chunks, function(chunk) {\n      if(!Buffer.isBuffer(chunk)) {\n        if (typeof chunk === 'string') {\n          chunk = new Buffer(chunk);\n        } else {\n          throw new Error('content-encoded responses must all be binary buffers');\n        }\n      }\n\n      return chunk.toString('hex');\n    });\n  }\n\n  var mergedBuffer = common.mergeChunks(chunks);\n\n  //  The merged buffer can be one of three things:\n  //    1.  A binary buffer which then has to be recorded as a hex string.\n  //    2.  A string buffer which represents a JSON object.\n  //    3.  A string buffer which doesn't represent a JSON object.\n\n  if(common.isBinaryBuffer(mergedBuffer)) {\n    return mergedBuffer.toString('hex');\n  } else {\n    var maybeStringifiedJson = mergedBuffer.toString('utf8');\n    try {\n      return JSON.parse(maybeStringifiedJson);\n    } catch(err) {\n      return maybeStringifiedJson;\n    }\n  }\n\n};\n\nfunction generateRequestAndResponseObject(req, bodyChunks, options, res, dataChunks) {\n\n  options.path = req.path;\n  return {\n    scope:    getScope(options),\n    method:   getMethod(options),\n    path:     options.path,\n    body:     getBodyFromChunks(bodyChunks),\n    status:   res.statusCode,\n    response: getBodyFromChunks(dataChunks, res.headers),\n    rawHeaders: res.rawHeaders || res.headers,\n    reqheaders: req._headers\n  };\n\n}\n\nfunction generateRequestAndResponse(req, bodyChunks, options, res, dataChunks) {\n\n  var requestBody = getBodyFromChunks(bodyChunks);\n  var responseBody = getBodyFromChunks(dataChunks, res.headers);\n\n  // Remove any query params from options.path so they can be added in the query() function\n  var path = options.path;\n  var queryIndex = 0;\n  var queryObj = {};\n  if ((queryIndex = req.path.indexOf('?')) !== -1) {\n    path = path.substring(0, queryIndex);\n\n    // Create the query() object\n    var queries = req.path.slice(queryIndex + 1).split('&');\n\n    for (var i = 0; i < queries.length; i++) {\n      var query = queries[i].split('=');\n      queryObj[query[0]] = query[1];\n    }\n  }\n\n  var ret = [];\n  ret.push('\\nnock(\\'');\n  ret.push(getScope(options));\n  ret.push('\\', ');\n  ret.push(JSON.stringify({ encodedQueryParams: true }));\n  ret.push(')\\n');\n  ret.push('  .');\n  ret.push(getMethod(options).toLowerCase());\n  ret.push('(\\'');\n  ret.push(path);\n  ret.push(\"'\");\n  if (requestBody) {\n    ret.push(', ');\n    ret.push(JSON.stringify(requestBody));\n  }\n  ret.push(\")\\n\");\n  if (req.headers) {\n    for (var k in req.headers) {\n      ret.push('  .matchHeader(' + JSON.stringify(k) + ', ' + JSON.stringify(req.headers[k]) + ')\\n');\n    }\n  }\n\n  if (queryIndex !== -1) {\n    ret.push('  .query(');\n    ret.push(JSON.stringify(queryObj));\n    ret.push(')\\n');\n  }\n\n  ret.push('  .reply(');\n  ret.push(res.statusCode.toString());\n  ret.push(', ');\n  ret.push(JSON.stringify(responseBody));\n  if (res.rawHeaders) {\n    ret.push(', ');\n    ret.push(inspect(res.rawHeaders));\n  } else if (res.headers) {\n    ret.push(', ');\n    ret.push(inspect(res.headers));\n  }\n  ret.push(');\\n');\n\n  return ret.join('');\n}\n\n//  This module variable is used to identify a unique recording ID in order to skip\n//  spurious requests that sometimes happen. This problem has been, so far,\n//  exclusively detected in nock's unit testing where 'checks if callback is specified'\n//  interferes with other tests as its t.end() is invoked without waiting for request\n//  to finish (which is the point of the test).\nvar currentRecordingId = 0;\n\nfunction record(rec_options) {\n\n  //  Set the new current recording ID and capture its value in this instance of record().\n  currentRecordingId = currentRecordingId + 1;\n  var thisRecordingId = currentRecordingId;\n\n  debug('start recording', thisRecordingId, JSON.stringify(rec_options));\n\n  //  Trying to start recording with recording already in progress implies an error\n  //  in the recording configuration (double recording makes no sense and used to lead\n  //  to duplicates in output)\n  if(recordingInProgress) {\n    throw new Error('Nock recording already in progress');\n  }\n\n  recordingInProgress = true;\n\n  //  Originaly the parameters was a dont_print boolean flag.\n  //  To keep the existing code compatible we take that case into account.\n  var optionsIsObject = typeof rec_options === 'object';\n  var dont_print = (typeof rec_options === 'boolean' && rec_options) ||\n      (optionsIsObject && rec_options.dont_print);\n  var output_objects = optionsIsObject && rec_options.output_objects;\n  var enable_reqheaders_recording = optionsIsObject && rec_options.enable_reqheaders_recording;\n  var logging = (optionsIsObject && rec_options.logging) || console.log;\n  var use_separator = true;\n  if (optionsIsObject && _.has(rec_options, 'use_separator')) {\n    use_separator = rec_options.use_separator;\n  }\n\n  debug(thisRecordingId, 'restoring overridden requests before new overrides');\n  //  To preserve backward compatibility (starting recording wasn't throwing if nock was already active)\n  //  we restore any requests that may have been overridden by other parts of nock (e.g. intercept)\n  //  NOTE: This is hacky as hell but it keeps the backward compatibility *and* allows correct\n  //    behavior in the face of other modules also overriding ClientRequest.\n  common.restoreOverriddenRequests();\n  //  We restore ClientRequest as it messes with recording of modules that also override ClientRequest (e.g. xhr2)\n  intercept.restoreOverriddenClientRequest();\n\n  //  We override the requests so that we can save information on them before executing.\n  common.overrideRequests(function(proto, overriddenRequest, options, callback) {\n\n    var bodyChunks = [];\n\n    if (typeof options == 'string') {\n      var url = URL.parse(options);\n      options = {\n        hostname: url.hostname,\n        method: 'GET',\n        port: url.port,\n        path: url.path\n      };\n    }\n\n    // Node 0.11 https.request calls http.request -- don't want to record things\n    // twice.\n    if (options._recording) {\n      return overriddenRequest(options, callback);\n    }\n    options._recording = true;\n\n    var req = overriddenRequest(options, function(res) {\n\n      debug(thisRecordingId, 'intercepting', proto, 'request to record');\n\n      if (typeof options === 'string') {\n        options = parse(options);\n      }\n\n      //  We put our 'end' listener to the front of the listener array.\n      res.once('end', function() {\n        debug(thisRecordingId, proto, 'intercepted request ended');\n\n        var out;\n        if(output_objects) {\n          out = generateRequestAndResponseObject(req, bodyChunks, options, res, dataChunks);\n          if(out.reqheaders) {\n            //  We never record user-agent headers as they are worse than useless -\n            //  they actually make testing more difficult without providing any benefit (see README)\n            common.deleteHeadersField(out.reqheaders, 'user-agent');\n\n            //  Remove request headers completely unless it was explicitly enabled by the user (see README)\n            if(!enable_reqheaders_recording) {\n              delete out.reqheaders;\n            }\n          }\n        } else {\n          out = generateRequestAndResponse(req, bodyChunks, options, res, dataChunks);\n        }\n\n        debug('out:', out);\n\n        //  Check that the request was made during the current recording.\n        //  If it hasn't then skip it. There is no other simple way to handle\n        //  this as it depends on the timing of requests and responses. Throwing\n        //  will make some recordings/unit tests faily randomly depending on how\n        //  fast/slow the response arrived.\n        //  If you are seeing this error then you need to make sure that all\n        //  the requests made during a single recording session finish before\n        //  ending the same recording session.\n        if(thisRecordingId !== currentRecordingId) {\n          debug('skipping recording of an out-of-order request', out);\n          return;\n        }\n\n        outputs.push(out);\n\n        if (!dont_print) {\n          if (use_separator) {\n            logging(SEPARATOR + out + SEPARATOR);\n          } else {\n            logging(out);\n          }\n        }\n      });\n\n      var dataChunks = [];\n      var encoding;\n\n      // We need to be aware of changes to the stream's encoding so that we\n      // don't accidentally mangle the data.\n      var setEncoding = res.setEncoding;\n      res.setEncoding = function (newEncoding) {\n        encoding = newEncoding;\n        return setEncoding.apply(this, arguments);\n      };\n\n      // Replace res.push with our own implementation that stores chunks\n      var origResPush = res.push;\n      res.push = function(data) {\n        if (data) {\n          if (encoding) {\n            data = new Buffer(data, encoding);\n          }\n          dataChunks.push(data);\n        }\n\n        return origResPush.call(res, data);\n      }\n\n      if (callback) {\n        callback(res, options, callback);\n      } else {\n        res.resume();\n      }\n\n      debug('finished setting up intercepting');\n\n      if (proto === 'https') {\n        options._https_ = true;\n      }\n\n    });\n\n    var oldWrite = req.write;\n    req.write = function(data, encoding) {\n      if ('undefined' !== typeof(data)) {\n        if (data) {\n          debug(thisRecordingId, 'new', proto, 'body chunk');\n          if (! Buffer.isBuffer(data)) {\n            data = new Buffer(data, encoding);\n          }\n          bodyChunks.push(data);\n        }\n        oldWrite.call(req, data);\n      }\n    };\n\n    return req;\n  });\n}\n\n//  Restores *all* the overridden http/https modules' properties.\nfunction restore() {\n  debug(currentRecordingId, 'restoring all the overridden http/https properties');\n\n  common.restoreOverriddenRequests();\n  intercept.restoreOverriddenClientRequest();\n  recordingInProgress = false;\n}\n\nfunction clear() {\n  outputs = [];\n}\n\nexports.record = record;\nexports.outputs = function() {\n  return outputs;\n};\nexports.restore = restore;\nexports.clear = clear;\n","/home/travis/build/npmtest/node-npmtest-nock/nock/lib/common.js":"'use strict';\n\nvar _ = require('lodash');\nvar debug = require('debug')('nock.common');\n\n/**\n * Normalizes the request options so that it always has `host` property.\n *\n * @param  {Object} options - a parsed options object of the request\n */\nvar normalizeRequestOptions = function(options) {\n  options.proto = options.proto || (options._https_ ? 'https': 'http');\n  options.port = options.port || ((options.proto === 'http') ? 80 : 443);\n  if (options.host) {\n    debug('options.host:', options.host);\n    if (! options.hostname) {\n      if (options.host.split(':').length == 2) {\n        options.hostname = options.host.split(':')[0];\n      } else {\n        options.hostname = options.host;\n      }\n    }\n  }\n  debug('options.hostname in the end: %j', options.hostname);\n  options.host = (options.hostname || 'localhost') + ':' + options.port;\n  debug('options.host in the end: %j', options.host);\n\n  /// lowercase host names\n  ['hostname', 'host'].forEach(function(attr) {\n    if (options[attr]) {\n      options[attr] = options[attr].toLowerCase();\n    }\n  });\n\n  return options;\n};\n\n/**\n * Returns true if the data contained in buffer is binary which in this case means\n * that it cannot be reconstructed from its utf8 representation.\n *\n * @param  {Object} buffer - a Buffer object\n */\nvar isBinaryBuffer = function(buffer) {\n\n  if(!Buffer.isBuffer(buffer)) {\n    return false;\n  }\n\n  //  Test if the buffer can be reconstructed verbatim from its utf8 encoding.\n  var utfEncodedBuffer = buffer.toString('utf8');\n  var reconstructedBuffer = new Buffer(utfEncodedBuffer, 'utf8');\n  var compareBuffers = function(lhs, rhs) {\n    if(lhs.length !== rhs.length) {\n      return false;\n    }\n\n    for(var i = 0; i < lhs.length; ++i) {\n      if(lhs[i] !== rhs[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  //  If the buffers are *not* equal then this is a \"binary buffer\"\n  //  meaning that it cannot be faitfully represented in utf8.\n  return !compareBuffers(buffer, reconstructedBuffer);\n\n};\n\n/**\n * If the chunks are Buffer objects then it returns a single Buffer object with the data from all the chunks.\n * If the chunks are strings then it returns a single string value with data from all the chunks.\n *\n * @param  {Array} chunks - an array of Buffer objects or strings\n */\nvar mergeChunks = function(chunks) {\n\n  if(_.isEmpty(chunks)) {\n    return new Buffer(0);\n  }\n\n  //  We assume that all chunks are Buffer objects if the first is buffer object.\n  var areBuffers = Buffer.isBuffer(_.first(chunks));\n\n  if(!areBuffers) {\n    //  When the chunks are not buffers we assume that they are strings.\n    return chunks.join('');\n  }\n\n  //  Merge all the buffers into a single Buffer object.\n  return Buffer.concat(chunks);\n\n};\n\n//  Array where all information about all the overridden requests are held.\nvar requestOverride = [];\n\n/**\n * Overrides the current `request` function of `http` and `https` modules with\n * our own version which intercepts issues HTTP/HTTPS requests and forwards them\n * to the given `newRequest` function.\n *\n * @param  {Function} newRequest - a function handling requests; it accepts four arguments:\n *   - proto - a string with the overridden module's protocol name (either `http` or `https`)\n *   - overriddenRequest - the overridden module's request function already bound to module's object\n *   - options - the options of the issued request\n *   - callback - the callback of the issued request\n */\nvar overrideRequests = function(newRequest) {\n  debug('overriding requests');\n\n  ['http', 'https'].forEach(function(proto) {\n    debug('- overriding request for', proto);\n\n    var moduleName = proto, // 1 to 1 match of protocol and module is fortunate :)\n        module = {\n          http: require('http'),\n          https: require('https')\n        }[moduleName],\n        overriddenRequest = module.request;\n\n    if(requestOverride[moduleName]) {\n      throw new Error('Module\\'s request already overridden for ' + moduleName + ' protocol.');\n    }\n\n    //  Store the properties of the overridden request so that it can be restored later on.\n    requestOverride[moduleName] = {\n      module: module,\n      request: overriddenRequest\n    };\n\n    module.request = function(options, callback) {\n      // debug('request options:', options);\n      return newRequest(proto, overriddenRequest.bind(module), options, callback);\n    };\n\n    debug('- overridden request for', proto);\n  });\n};\n\n/**\n * Restores `request` function of `http` and `https` modules to values they\n * held before they were overridden by us.\n */\nvar restoreOverriddenRequests = function() {\n  debug('restoring requests');\n\n  //  Restore any overridden requests.\n  _(requestOverride).keys().each(function(proto) {\n    debug('- restoring request for', proto);\n\n    var override = requestOverride[proto];\n    if(override) {\n      override.module.request = override.request;\n      debug('- restored request for', proto);\n    }\n  });\n  requestOverride = [];\n};\n\n/**\n * Get high level information about request as string\n * @param  {Object} options\n * @param  {string} options.method\n * @param  {string} options.port\n * @param  {string} options.proto\n * @param  {string} options.hostname\n * @param  {string} options.path\n * @param  {Object} options.headers\n * @param  {string|object} body\n * @return {string}\n */\nfunction stringifyRequest(options, body) {\n  var method = options.method || 'GET';\n\n  var port = options.port;\n  if (! port) port = (options.proto == 'https' ? '443' : '80');\n\n  if (options.proto == 'https' && port == '443' ||\n      options.proto == 'http' && port == '80') {\n    port = '';\n  }\n\n  if (port) port = ':' + port;\n\n  var log = {\n    method: method,\n    url: options.proto + '://' + options.hostname + port + options.path,\n    headers: options.headers\n  };\n\n  if (body) {\n    log.body = body;\n  }\n\n  return JSON.stringify(log, null, 2);\n}\n\nfunction isContentEncoded(headers) {\n  var contentEncoding = _.get(headers, 'content-encoding');\n  return _.isString(contentEncoding) && contentEncoding !== '';\n}\n\nfunction contentEncoding(headers, encoder) {\n  var contentEncoding = _.get(headers, 'content-encoding');\n  return contentEncoding === encoder;\n}\n\nfunction isJSONContent(headers) {\n  var contentType = _.get(headers, 'content-type');\n  if (Array.isArray(contentType)) {\n    contentType = contentType[0];\n  }\n  contentType = (contentType || '').toLocaleLowerCase();\n\n  return contentType === 'application/json';\n}\n\nvar headersFieldNamesToLowerCase = function(headers) {\n  if(!_.isObject(headers)) {\n    return headers;\n  }\n\n  //  For each key in the headers, delete its value and reinsert it with lower-case key.\n  //  Keys represent headers field names.\n  var lowerCaseHeaders = {};\n  _.forOwn(headers, function(fieldVal, fieldName) {\n    var lowerCaseFieldName = fieldName.toLowerCase();\n    if(!_.isUndefined(lowerCaseHeaders[lowerCaseFieldName])) {\n      throw new Error('Failed to convert header keys to lower case due to field name conflict: ' + lowerCaseFieldName);\n    }\n    lowerCaseHeaders[lowerCaseFieldName] = fieldVal;\n  });\n\n  return lowerCaseHeaders;\n};\n\nvar headersFieldsArrayToLowerCase = function (headers) {\n  return _.uniq(_.map(headers, function (fieldName) {\n    return fieldName.toLowerCase();\n  }));\n};\n\nvar headersArrayToObject = function (rawHeaders) {\n  if(!_.isArray(rawHeaders)) {\n    return rawHeaders;\n  }\n\n  var headers = {};\n\n  for (var i=0, len=rawHeaders.length; i<len; i=i+2) {\n    var key = rawHeaders[i];\n    var value = rawHeaders[i+1];\n\n    if (headers[key]) {\n      headers[key] = _.isArray(headers[key]) ? headers[key] : [headers[key]];\n      headers[key].push(value);\n    } else {\n      headers[key] = value;\n    }\n  }\n\n  return headers;\n};\n\n/**\n * Deletes the given `fieldName` property from `headers` object by performing\n * case-insensitive search through keys.\n *\n * @headers   {Object} headers - object of header field names and values\n * @fieldName {String} field name - string with the case-insensitive field name\n */\nvar deleteHeadersField = function(headers, fieldNameToDelete) {\n\n  if(!_.isObject(headers) || !_.isString(fieldNameToDelete)) {\n    return;\n  }\n\n  var lowerCaseFieldNameToDelete = fieldNameToDelete.toLowerCase();\n\n  //  Search through the headers and delete all values whose field name matches the given field name.\n  _(headers).keys().each(function(fieldName) {\n    var lowerCaseFieldName = fieldName.toLowerCase();\n    if(lowerCaseFieldName === lowerCaseFieldNameToDelete) {\n      delete headers[fieldName];\n      //  We don't stop here but continue in order to remove *all* matching field names\n      //  (even though if seen regorously there shouldn't be any)\n    }\n  });\n\n};\n\nfunction percentDecode (str) {\n  try {\n    return decodeURIComponent(str.replace(/\\+/g, ' '));\n  } catch (e) {\n    return str;\n  }\n}\n\nfunction percentEncode(str) {\n  return encodeURIComponent(str).replace(/[!'()*]/g, function(c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase();\n  });\n}\n\nfunction matchStringOrRegexp(target, pattern) {\n  var str = target && target.toString ? target.toString() : target;\n\n  return pattern instanceof RegExp  ? str.match(pattern) : str === pattern;\n}\n\n// return [newKey, newValue]\nfunction formatQueryValue(key, value, options) {\n  switch (true) {\n    case _.isNumber(value): // fall-though\n    case _.isBoolean(value):\n      value = value.toString();\n      break;\n    case _.isUndefined(value): // fall-though\n    case _.isNull(value):\n      value = '';\n      break;\n    case _.isString(value):\n      if(options.encodedQueryParams) {\n        value = percentDecode(value);\n      }\n      break;\n    case (value instanceof RegExp):\n      break;\n    case _.isArray(value):\n      var tmpArray = new Array(value.length);\n      for (var i = 0; i < value.length; ++i) {\n        tmpArray[i] = formatQueryValue(i, value[i], options)[1];\n      }\n      value = tmpArray;\n      break;\n    case _.isObject(value):\n      var tmpObj = {};\n      _.forOwn(value, function(subVal, subKey){\n        var subPair = formatQueryValue(subKey, subVal, options);\n        tmpObj[subPair[0]] = subPair[1];\n      });\n      value = tmpObj;\n      break;\n  }\n\n  if (options.encodedQueryParams) key = percentDecode(key);\n  return [key, value];\n}\n\nfunction isStream(obj) {\n  return obj &&\n      (typeof a !== 'string') &&\n      (! Buffer.isBuffer(obj)) &&\n      _.isFunction(obj.setEncoding);\n}\n\nexports.normalizeRequestOptions = normalizeRequestOptions;\nexports.isBinaryBuffer = isBinaryBuffer;\nexports.mergeChunks = mergeChunks;\nexports.overrideRequests = overrideRequests;\nexports.restoreOverriddenRequests = restoreOverriddenRequests;\nexports.stringifyRequest = stringifyRequest;\nexports.isContentEncoded = isContentEncoded;\nexports.contentEncoding = contentEncoding;\nexports.isJSONContent = isJSONContent;\nexports.headersFieldNamesToLowerCase = headersFieldNamesToLowerCase;\nexports.headersFieldsArrayToLowerCase = headersFieldsArrayToLowerCase;\nexports.headersArrayToObject = headersArrayToObject;\nexports.deleteHeadersField = deleteHeadersField;\nexports.percentEncode = percentEncode;\nexports.percentDecode = percentDecode;\nexports.matchStringOrRegexp = matchStringOrRegexp;\nexports.formatQueryValue = formatQueryValue;\nexports.isStream = isStream;\n","/home/travis/build/npmtest/node-npmtest-nock/nock/lib/intercept.js":"'use strict';\n\n/**\n * @module nock/intercepts\n */\n\nvar RequestOverrider = require('./request_overrider'),\n    common           = require('./common'),\n    url              = require('url'),\n    inherits         = require('util').inherits,\n    Interceptor      = require('./interceptor'),\n    http             = require('http'),\n    parse            = require('url').parse,\n    _                = require('lodash'),\n    debug            = require('debug')('nock.intercept'),\n    timers           = require('timers'),\n    EventEmitter     = require('events').EventEmitter,\n    globalEmitter    = require('./global_emitter');\n\n\n/**\n * @name NetConnectNotAllowedError\n * @private\n * @desc Error trying to make a connection when disabled external access.\n * @class\n * @example\n * nock.disableNetConnect();\n * http.get('http://zombo.com');\n * // throw NetConnectNotAllowedError\n */\nfunction NetConnectNotAllowedError(host, path) {\n  Error.call(this);\n\n  this.name    = 'NetConnectNotAllowedError';\n  this.message = 'Nock: Not allow net connect for \"' + host + path + '\"';\n\n  Error.captureStackTrace(this, this.constructor);\n}\n\ninherits(NetConnectNotAllowedError, Error);\n\nvar allInterceptors = {},\n    allowNetConnect;\n\n/**\n * Enabled real request.\n * @public\n * @param {String|RegExp} matcher=RegExp.new('.*') Expression to match\n * @example\n * // Enables all real requests\n * nock.enableNetConnect();\n * @example\n * // Enables real requests for url that matches google\n * nock.enableNetConnect('google');\n * @example\n * // Enables real requests for url that matches google and amazon\n * nock.enableNetConnect(/(google|amazon)/);\n */\nfunction enableNetConnect(matcher) {\n  if (_.isString(matcher)) {\n    allowNetConnect = new RegExp(matcher);\n  } else if (_.isObject(matcher) && _.isFunction(matcher.test)) {\n    allowNetConnect = matcher;\n  } else {\n    allowNetConnect = /.*/;\n  }\n}\n\nfunction isEnabledForNetConnect(options) {\n  common.normalizeRequestOptions(options);\n\n  var enabled = allowNetConnect && allowNetConnect.test(options.host);\n  debug('Net connect', enabled ? '' : 'not', 'enabled for', options.host);\n  return enabled;\n}\n\n/**\n * Disable all real requests.\n * @public\n * @param {String|RegExp} matcher=RegExp.new('.*') Expression to match\n * @example\n * nock.disableNetConnect();\n*/\nfunction disableNetConnect() {\n  allowNetConnect = undefined;\n}\n\nfunction isOn() {\n  return !isOff();\n}\n\nfunction isOff() {\n  return process.env.NOCK_OFF === 'true';\n}\n\nfunction add(key, interceptor, scope, scopeOptions, host) {\n  if (! allInterceptors.hasOwnProperty(key)) {\n    allInterceptors[key] = { key: key, scopes: [] };\n  }\n  interceptor.__nock_scope = scope;\n\n  //  We need scope's key and scope options for scope filtering function (if defined)\n  interceptor.__nock_scopeKey = key;\n  interceptor.__nock_scopeOptions = scopeOptions;\n  //  We need scope's host for setting correct request headers for filtered scopes.\n  interceptor.__nock_scopeHost = host;\n  interceptor.interceptionCounter = 0;\n\n  allInterceptors[key].scopes.push(interceptor);\n}\n\nfunction remove(interceptor) {\n  if (interceptor.__nock_scope.shouldPersist() || --interceptor.counter > 0) {\n    return;\n  }\n\n  var basePath = interceptor.basePath;\n  var interceptors = allInterceptors[basePath] && allInterceptors[basePath].scopes || [];\n\n  interceptors.some(function (thisInterceptor, i) {\n    return (thisInterceptor === interceptor) ? interceptors.splice(i, 1) : false;\n  });\n}\n\nfunction removeAll() {\n  Object.keys(allInterceptors).forEach(function(key) {\n    allInterceptors[key].scopes.forEach(function(interceptor) {\n      interceptor.scope.keyedInterceptors = {};\n    });\n  });\n  allInterceptors = {};\n}\n\nfunction interceptorsFor(options) {\n  var basePath,\n      matchingInterceptor;\n\n  common.normalizeRequestOptions(options);\n\n  debug('interceptors for %j', options.host);\n\n  basePath = options.proto + '://' + options.host;\n\n  debug('filtering interceptors for basepath', basePath);\n\n  //  First try to use filteringScope if any of the interceptors has it defined.\n  _.each(allInterceptors, function(interceptor, k) {\n    _.each(interceptor.scopes, function(scope) {\n      var filteringScope = scope.__nock_scopeOptions.filteringScope;\n\n      //  If scope filtering function is defined and returns a truthy value\n      //  then we have to treat this as a match.\n      if(filteringScope && filteringScope(basePath)) {\n        debug('found matching scope interceptor');\n\n        //  Keep the filtered scope (its key) to signal the rest of the module\n        //  that this wasn't an exact but filtered match.\n        scope.__nock_filteredScope = scope.__nock_scopeKey;\n        matchingInterceptor = interceptor.scopes;\n        //  Break out of _.each for scopes.\n        return false;\n      }\n    });\n\n    if (!matchingInterceptor && common.matchStringOrRegexp(basePath, interceptor.key)) {\n      matchingInterceptor = interceptor.scopes;\n      // false to short circuit the .each\n      return false;\n    }\n\n    //  Returning falsy value here (which will happen if we have found our matching interceptor)\n    //  will break out of _.each for all interceptors.\n    return !matchingInterceptor;\n  });\n\n  return matchingInterceptor;\n}\n\nfunction removeInterceptor(options) {\n  var baseUrl, key, method, proto;\n  if (options instanceof Interceptor) {\n    baseUrl = options.basePath;\n    key = options._key;\n  } else {\n    proto = options.proto ? options.proto : 'http';\n\n    common.normalizeRequestOptions(options);\n    baseUrl = proto + '://' + options.host;\n    method = options.method && options.method.toUpperCase() || 'GET';\n    key = method + ' ' + baseUrl + (options.path || '/');\n  }\n\n  if (allInterceptors[baseUrl] && allInterceptors[baseUrl].scopes.length > 0) {\n    if (key) {\n      for (var i = 0; i < allInterceptors[baseUrl].scopes.length; i++) {\n        var interceptor = allInterceptors[baseUrl].scopes[i];\n        if (interceptor._key === key) {\n          allInterceptors[baseUrl].scopes.splice(i, 1);\n          interceptor.scope.remove(key, interceptor);\n          break;\n        }\n      }\n    } else {\n      allInterceptors[baseUrl].scopes.length = 0;\n    }\n\n    return true;\n  }\n\n  return false;\n}\n//  Variable where we keep the ClientRequest we have overridden\n//  (which might or might not be node's original http.ClientRequest)\nvar originalClientRequest;\n\nfunction ErroringClientRequest(error) {\n  if (http.OutgoingMessage) http.OutgoingMessage.call(this);\n  process.nextTick(function() {\n    this.emit('error', error);\n  }.bind(this));\n}\n\nif (http.ClientRequest) {\n  inherits(ErroringClientRequest, http.ClientRequest);\n}\n\nfunction overrideClientRequest() {\n  debug('Overriding ClientRequest');\n\n  if(originalClientRequest) {\n    throw new Error('Nock already overrode http.ClientRequest');\n  }\n\n  // ----- Extending http.ClientRequest\n\n  //  Define the overriding client request that nock uses internally.\n  function OverriddenClientRequest(options, cb) {\n    if (http.OutgoingMessage) http.OutgoingMessage.call(this);\n\n    //  Filter the interceptors per request options.\n    var interceptors = interceptorsFor(options);\n\n    if (isOn() && interceptors) {\n      debug('using', interceptors.length, 'interceptors');\n\n      //  Use filtered interceptors to intercept requests.\n      var overrider = RequestOverrider(this, options, interceptors, remove, cb);\n      for(var propName in overrider) {\n        if (overrider.hasOwnProperty(propName)) {\n          this[propName] = overrider[propName];\n        }\n      }\n    } else {\n      debug('falling back to original ClientRequest');\n\n      //  Fallback to original ClientRequest if nock is off or the net connection is enabled.\n      if(isOff() || isEnabledForNetConnect(options)) {\n        originalClientRequest.apply(this, arguments);\n      } else {\n        timers.setImmediate(function () {\n          var error = new NetConnectNotAllowedError(options.host, options.path);\n          this.emit('error', error);\n        }.bind(this));\n      }\n    }\n  }\n  if (http.ClientRequest) {\n    inherits(OverriddenClientRequest, http.ClientRequest);\n  } else {\n    inherits(OverriddenClientRequest, EventEmitter);\n  }\n\n  //  Override the http module's request but keep the original so that we can use it and later restore it.\n  //  NOTE: We only override http.ClientRequest as https module also uses it.\n  originalClientRequest = http.ClientRequest;\n  http.ClientRequest = OverriddenClientRequest;\n\n  debug('ClientRequest overridden');\n}\n\nfunction restoreOverriddenClientRequest() {\n  debug('restoring overriden ClientRequest');\n\n  //  Restore the ClientRequest we have overridden.\n  if(!originalClientRequest) {\n    debug('- ClientRequest was not overridden');\n  } else {\n    http.ClientRequest = originalClientRequest;\n    originalClientRequest = undefined;\n\n    debug('- ClientRequest restored');\n  }\n}\n\nfunction isActive() {\n\n  //  If ClientRequest has been overwritten by Nock then originalClientRequest is not undefined.\n  //  This means that Nock has been activated.\n  return !_.isUndefined(originalClientRequest);\n\n}\n\nfunction interceptorScopes() {\n  return _.reduce(allInterceptors, function(result, interceptors) {\n    for (var interceptor in interceptors.scopes) {\n      result = result.concat(interceptors.scopes[interceptor].__nock_scope);\n    }\n\n    return result;\n  }, []);\n}\n\nfunction isDone() {\n  return _.every(interceptorScopes(), function(scope) {\n    return scope.isDone();\n  });\n}\n\nfunction pendingMocks() {\n  return _.flatten(_.map(interceptorScopes(), function(scope) {\n    return scope.pendingMocks();\n  }));\n}\n\nfunction activeMocks() {\n  return _.flatten(_.map(interceptorScopes(), function(scope) {\n    return scope.activeMocks();\n  }));\n}\n\nfunction activate() {\n\n  if(originalClientRequest) {\n    throw new Error('Nock already active');\n  }\n\n  overrideClientRequest();\n\n  // ----- Overriding http.request and https.request:\n\n  common.overrideRequests(function(proto, overriddenRequest, options, callback) {\n    //  NOTE: overriddenRequest is already bound to its module.\n    var req,\n        res;\n\n    if (typeof options === 'string') {\n      options = parse(options);\n    }\n    options.proto = proto;\n\n    var interceptors = interceptorsFor(options)\n\n    if (isOn() && interceptors) {\n      var matches = false,\n          allowUnmocked = false;\n\n      matches = !! _.find(interceptors, function(interceptor) {\n        return interceptor.matchIndependentOfBody(options);\n      });\n\n      allowUnmocked = !! _.find(interceptors, function(interceptor) {\n        return interceptor.options.allowUnmocked;\n      });\n\n      if (! matches && allowUnmocked) {\n        if (proto === 'https') {\n          var ClientRequest = http.ClientRequest;\n          http.ClientRequest = originalClientRequest;\n          req = overriddenRequest(options, callback);\n          http.ClientRequest = ClientRequest;\n        } else {\n          req = overriddenRequest(options, callback);\n        }\n        globalEmitter.emit('no match', req);\n        return req;\n      }\n\n      //  NOTE: Since we already overrode the http.ClientRequest we are in fact constructing\n      //    our own OverriddenClientRequest.\n      req = new http.ClientRequest(options);\n\n      res = RequestOverrider(req, options, interceptors, remove);\n      if (callback) {\n        res.on('response', callback);\n      }\n      return req;\n    } else {\n      globalEmitter.emit('no match', options);\n      if (isOff() || isEnabledForNetConnect(options)) {\n        return overriddenRequest(options, callback);\n      } else {\n        var error = new NetConnectNotAllowedError(options.host, options.path);\n        return new ErroringClientRequest(error);\n      }\n    }\n  });\n\n}\n\nactivate();\n\nmodule.exports = add;\nmodule.exports.removeAll = removeAll;\nmodule.exports.removeInterceptor = removeInterceptor;\nmodule.exports.isOn = isOn;\nmodule.exports.activate = activate;\nmodule.exports.isActive = isActive;\nmodule.exports.isDone = isDone;\nmodule.exports.pendingMocks = pendingMocks;\nmodule.exports.activeMocks = activeMocks;\nmodule.exports.enableNetConnect = enableNetConnect;\nmodule.exports.disableNetConnect = disableNetConnect;\nmodule.exports.overrideClientRequest = overrideClientRequest;\nmodule.exports.restoreOverriddenClientRequest = restoreOverriddenClientRequest;\n","/home/travis/build/npmtest/node-npmtest-nock/nock/lib/request_overrider.js":"'use strict';\n\nvar EventEmitter     = require('events').EventEmitter,\n    http             = require('http'),\n    propagate        = require('propagate'),\n    DelayedBody      = require('./delayed_body'),\n    IncomingMessage  = http.IncomingMessage,\n    ClientRequest    = http.ClientRequest,\n    common           = require('./common'),\n    Socket           = require('./socket'),\n    _                = require('lodash'),\n    debug            = require('debug')('nock.request_overrider'),\n    timers           = require('timers'),\n    ReadableStream   = require('stream').Readable,\n    globalEmitter    = require('./global_emitter'),\n    zlib             = require('zlib');\n\nfunction getHeader(request, name) {\n  if (!request._headers) {\n    return;\n  }\n\n  var key = name.toLowerCase();\n\n  return request._headers[key];\n}\n\nfunction setHeader(request, name, value) {\n  debug('setHeader', name, value);\n\n  var key = name.toLowerCase();\n\n  request._headers = request._headers || {};\n  request._headerNames = request._headerNames || {};\n  request._removedHeader = request._removedHeader || {};\n\n  request._headers[key] = value;\n  request._headerNames[key] = name;\n\n  if (name == 'expect' && value == '100-continue') {\n    timers.setImmediate(function() {\n      debug('continue');\n      request.emit('continue');\n    });\n  }\n}\n\n//  Sets request headers of the given request. This is needed during both matching phase\n//  (in case header filters were specified) and mocking phase (to correctly pass mocked\n//  request headers).\nfunction setRequestHeaders(req, options, interceptor) {\n  //  We mock request headers if these were specified.\n  if (interceptor.reqheaders) {\n    _.forOwn(interceptor.reqheaders, function(val, key) {\n      setHeader(req, key, val);\n    });\n  }\n\n  //  If a filtered scope is being used we have to use scope's host\n  //  in the header, otherwise 'host' header won't match.\n  //  NOTE: We use lower-case header field names throught Nock.\n  var HOST_HEADER = 'host';\n  if(interceptor.__nock_filteredScope && interceptor.__nock_scopeHost) {\n    if(options && options.headers) {\n      options.headers[HOST_HEADER] = interceptor.__nock_scopeHost;\n    }\n    setHeader(req, HOST_HEADER, interceptor.__nock_scopeHost);\n  } else {\n    //  For all other cases, we always add host header equal to the\n    //  requested host unless it was already defined.\n    if (options.host && !getHeader(req, HOST_HEADER)) {\n      var hostHeader = options.host;\n\n      if (options.port === 80 || options.port === 443) {\n        hostHeader = hostHeader.split(':')[0];\n      }\n\n      setHeader(req, HOST_HEADER, hostHeader);\n    }\n  }\n\n}\n\nfunction RequestOverrider(req, options, interceptors, remove, cb) {\n  var response;\n  if (IncomingMessage) {\n    response = new IncomingMessage(new EventEmitter());\n  } else {\n    response = new ReadableStream();\n    response._read = function() {};\n  }\n\n  var requestBodyBuffers = [],\n      aborted,\n      emitError,\n      end,\n      ended,\n      headers,\n      keys,\n      key,\n      i,\n      l;\n\n  //  We may be changing the options object and we don't want those\n  //  changes affecting the user so we use a clone of the object.\n  options = _.clone(options) || {};\n\n  response.req = req;\n\n  if (options.headers) {\n    //  We use lower-case header field names throught Nock.\n    options.headers = common.headersFieldNamesToLowerCase(options.headers);\n\n    headers = options.headers;\n    _.forOwn(headers, function(val, key) {\n      setHeader(req, key, val);\n    });\n  }\n\n  /// options.auth\n  if (options.auth && (! options.headers || ! options.headers.authorization)) {\n    setHeader(req, 'Authorization', 'Basic ' + (new Buffer(options.auth)).toString('base64'));\n  }\n\n  if (! req.connection) {\n    req.connection = new EventEmitter();\n  }\n\n  req.path = options.path;\n\n  options.getHeader = function(name) {\n    return getHeader(req, name);\n  };\n\n  req.socket = response.socket = Socket({ proto: options.proto });\n\n  req.write = function(buffer, encoding) {\n    debug('write', arguments);\n    if (buffer && !aborted) {\n      if (! Buffer.isBuffer(buffer)) {\n        buffer = new Buffer(buffer, encoding);\n      }\n      requestBodyBuffers.push(buffer);\n    }\n    if (aborted) {\n      emitError(new Error('Request aborted'));\n    }\n\n    timers.setImmediate(function() {\n      req.emit('drain');\n    });\n\n    return false;\n  };\n\n  req.end = function(buffer, encoding) {\n    debug('req.end');\n    if (!aborted && !ended) {\n      req.write(buffer, encoding);\n      end(cb);\n      req.emit('finish');\n      req.emit('end');\n    }\n    if (aborted) {\n      emitError(new Error('Request aborted'));\n    }\n  };\n\n  req.abort = function() {\n    debug('req.abort');\n    aborted = true;\n    if (!ended) {\n      end();\n    }\n    var err = new Error();\n    err.code = 'aborted';\n    response.emit('close', err);\n\n    req.socket.destroy();\n\n    req.emit('abort');\n\n    var connResetError = new Error('socket hang up');\n    connResetError.code = 'ECONNRESET';\n    emitError(connResetError);\n  };\n\n  // restify listens for a 'socket' event to\n  // be emitted before calling end(), which causes\n  // nock to hang with restify. The following logic\n  // fakes the socket behavior for restify,\n  // Fixes: https://github.com/pgte/nock/issues/79\n  req.once = req.on = function(event, listener) {\n    // emit a fake socket.\n    if (event == 'socket') {\n      listener.call(req, req.socket);\n      req.socket.emit('connect', req.socket);\n      req.socket.emit('secureConnect', req.socket);\n    }\n\n    EventEmitter.prototype.on.call(this, event, listener);\n    return this;\n  };\n\n  emitError = function(error) {\n    process.nextTick(function () {\n      req.emit('error', error);\n    });\n  };\n\n  end = function(cb) {\n    debug('ending');\n    ended = true;\n    var requestBody,\n        responseBody,\n        responseBuffers,\n        interceptor;\n\n    var continued = false;\n\n    //  When request body is a binary buffer we internally use in its hexadecimal representation.\n    var requestBodyBuffer = common.mergeChunks(requestBodyBuffers);\n    var isBinaryRequestBodyBuffer = common.isBinaryBuffer(requestBodyBuffer);\n    if(isBinaryRequestBodyBuffer) {\n      requestBody = requestBodyBuffer.toString('hex');\n    } else {\n      requestBody = requestBodyBuffer.toString('utf8');\n    }\n\n    /// put back the path into options\n    /// because bad behaving agents like superagent\n    /// like to change request.path in mid-flight.\n    options.path = req.path;\n\n    interceptors.forEach(function(interceptor) {\n      //  For correct matching we need to have correct request headers - if these were specified.\n      setRequestHeaders(req, options, interceptor);\n    });\n\n    interceptor = _.find(interceptors, function(interceptor) {\n      return interceptor.match(options, requestBody);\n    });\n\n    if (!interceptor) {\n      globalEmitter.emit('no match', req, options, requestBody);\n      // Try to find a hostname match\n      interceptor = _.find(interceptors, function(interceptor) {\n        return interceptor.match(options, requestBody, true);\n      });\n      if (interceptor && req instanceof ClientRequest) {\n        if (interceptor.options.allowUnmocked) {\n          var newReq = new ClientRequest(options, cb);\n          propagate(newReq, req);\n          //  We send the raw buffer as we received it, not as we interpreted it.\n          newReq.end(requestBodyBuffer);\n          return;\n        }\n      }\n\n      var err = new Error(\"Nock: No match for request \" + common.stringifyRequest(options, requestBody));\n      err.statusCode = err.status = 404;\n      emitError(err);\n      return;\n    }\n\n    debug('interceptor identified, starting mocking');\n\n    //  We again set request headers, now for our matched interceptor.\n    setRequestHeaders(req, options, interceptor);\n    interceptor.req = req;\n    req.headers = req._headers;\n\n    interceptor.scope.emit('request', req, interceptor);\n\n    if (typeof interceptor.errorMessage !== 'undefined') {\n      interceptor.interceptionCounter++;\n      remove(interceptor);\n      interceptor.discard();\n\n      var error;\n      if (_.isObject(interceptor.errorMessage)) {\n        error = interceptor.errorMessage;\n      } else {\n        error = new Error(interceptor.errorMessage);\n      }\n      timers.setTimeout(emitError, interceptor.getTotalDelay(), error);\n      return;\n    }\n    response.statusCode = Number(interceptor.statusCode) || 200;\n\n    // Clone headers/rawHeaders to not override them when evaluating later\n    response.headers = _.extend({}, interceptor.headers);\n    response.rawHeaders = (interceptor.rawHeaders || []).slice();\n    debug('response.rawHeaders:', response.rawHeaders);\n\n\n    if (typeof interceptor.body === 'function') {\n      if (requestBody && common.isJSONContent(options.headers)) {\n        if (requestBody && common.contentEncoding(options.headers, 'gzip')) {\n          if (typeof zlib.gunzipSync !== 'function') {\n            emitError(new Error('Gzip encoding is currently not supported in this version of Node.'));\n            return;\n          }\n          requestBody = String(zlib.gunzipSync(new Buffer(requestBody, 'hex')), 'hex')\n        } else if (requestBody && common.contentEncoding(options.headers, 'deflate')) {\n          if (typeof zlib.deflateSync !== 'function') {\n            emitError(new Error('Deflate encoding is currently not supported in this version of Node.'));\n            return;\n          }\n          requestBody = String(zlib.inflateSync(new Buffer(requestBody, 'hex')), 'hex')\n        }\n\n        requestBody = JSON.parse(requestBody);\n      }\n\n      // In case we are waiting for a callback\n      if (interceptor.body.length === 3) {\n        return interceptor.body(options.path, requestBody || '', continueWithResponseBody);\n      }\n\n      responseBody = interceptor.body(options.path, requestBody) || '';\n\n    } else {\n\n      //  If the content is encoded we know that the response body *must* be an array\n      //  of response buffers which should be mocked one by one.\n      //  (otherwise decompressions after the first one fails as unzip expects to receive\n      //  buffer by buffer and not one single merged buffer)\n      if(common.isContentEncoded(response.headers) && ! common.isStream(interceptor.body)) {\n\n        if (interceptor.delayInMs) {\n          emitError(new Error('Response delay is currently not supported with content-encoded responses.'));\n          return;\n        }\n\n        var buffers = interceptor.body;\n        if(!_.isArray(buffers)) {\n          buffers = [buffers];\n        }\n\n        responseBuffers = _.map(buffers, function(buffer) {\n          return new Buffer(buffer, 'hex');\n        });\n\n      } else {\n\n        responseBody = interceptor.body;\n\n        //  If the request was binary then we assume that the response will be binary as well.\n        //  In that case we send the response as a Buffer object as that's what the client will expect.\n        if(isBinaryRequestBodyBuffer && typeof(responseBody) === 'string') {\n          //  Try to create the buffer from the interceptor's body response as hex.\n          try {\n            responseBody = new Buffer(responseBody, 'hex');\n          } catch(err) {\n            debug('exception during Buffer construction from hex data:', responseBody, '-', err);\n          }\n\n          // Creating buffers does not necessarily throw errors, check for difference in size\n          if (!responseBody || (interceptor.body.length > 0 && responseBody.length === 0)) {\n            //  We fallback on constructing buffer from utf8 representation of the body.\n            responseBody = new Buffer(interceptor.body, 'utf8');\n          }\n        }\n      }\n    }\n\n    return continueWithResponseBody(null, responseBody);\n\n    function continueWithResponseBody(err, responseBody) {\n\n      if (continued) {\n        return;\n      }\n      continued = true;\n\n      if (err) {\n        response.statusCode = 500;\n        responseBody = err.stack;\n      }\n\n      //  Transform the response body if it exists (it may not exist\n      //  if we have `responseBuffers` instead)\n\n      if (responseBody) {\n        debug('transform the response body');\n\n        if (Array.isArray(responseBody) &&\n            responseBody.length >= 2 &&\n            responseBody.length <= 3 &&\n            typeof responseBody[0] == 'number')\n        {\n          debug('response body is array: %j', responseBody);\n          response.statusCode = Number(responseBody[0]);\n          debug('new headers: %j', responseBody[2]);\n          if (! response.headers) response.headers = {};\n          _.assign(response.headers, responseBody[2] || {});\n          debug('response.headers after: %j', response.headers);\n          responseBody = responseBody[1];\n\n          response.rawHeaders = response.rawHeaders || [];\n          Object.keys(response.headers).forEach(function(key) {\n            response.rawHeaders.push(key, response.headers[key]);\n          });\n        }\n\n        if (interceptor.delayInMs) {\n          debug('delaying the response for', interceptor.delayInMs, 'milliseconds');\n          // Because setTimeout is called immediately in DelayedBody(), so we\n          // need count in the delayConnectionInMs.\n          responseBody = new DelayedBody(interceptor.getTotalDelay(), responseBody);\n        }\n\n        if (common.isStream(responseBody)) {\n          debug('response body is a stream');\n          responseBody.pause();\n          responseBody.on('data', function(d) {\n            response.push(d);\n          });\n          responseBody.on('end', function() {\n            response.push(null);\n          });\n          responseBody.on('error', function(err) {\n            response.emit('error', err);\n          });\n        } else if (responseBody && !Buffer.isBuffer(responseBody)) {\n          if (typeof responseBody === 'string') {\n            responseBody = new Buffer(responseBody);\n          } else {\n            responseBody = JSON.stringify(responseBody);\n            response.headers['content-type'] = 'application/json';\n          }\n        }\n      }\n\n      interceptor.interceptionCounter++;\n      remove(interceptor);\n      interceptor.discard();\n\n      if (aborted) { return; }\n\n      /// response.client.authorized = true\n      /// fixes https://github.com/pgte/nock/issues/158\n      response.client = _.extend(response.client || {}, {\n        authorized: true\n      });\n\n      // Account for updates to Node.js response interface\n      // cf https://github.com/request/request/pull/1615\n      response.socket = _.extend(response.socket || {}, {\n        authorized: true\n      });\n\n      // Evaluate functional headers.\n      var evaluatedHeaders = {}\n      Object.keys(response.headers).forEach(function (key) {\n        var value = response.headers[key];\n\n        if (typeof value === \"function\") {\n          response.headers[key] = evaluatedHeaders[key] = value(req, response, responseBody);\n        }\n      });\n\n      for(var rawHeaderIndex = 0 ; rawHeaderIndex < response.rawHeaders.length ; rawHeaderIndex += 2) {\n        var key = response.rawHeaders[rawHeaderIndex];\n        var value = response.rawHeaders[rawHeaderIndex + 1];\n        if (typeof value === \"function\") {\n          response.rawHeaders[rawHeaderIndex + 1] = evaluatedHeaders[key.toLowerCase()];\n        }\n      }\n\n\n      process.nextTick(respond);\n\n      function respond() {\n\n        if (aborted) { return; }\n\n        if (interceptor.socketDelayInMs && interceptor.socketDelayInMs > 0) {\n          req.socket.applyDelay(interceptor.socketDelayInMs);\n        }\n\n        if (interceptor.delayConnectionInMs && interceptor.delayConnectionInMs > 0) {\n          setTimeout(_respond, interceptor.delayConnectionInMs);\n        } else {\n          _respond();\n        }\n\n        function _respond() {\n          if (aborted) { return; }\n\n          debug('emitting response');\n\n          if (typeof cb === 'function') {\n            debug('callback with response');\n            cb(response);\n          }\n\n          if (aborted) {\n            emitError(new Error('Request aborted'));\n          }\n          else {\n            req.emit('response', response);\n          }\n\n          if (common.isStream(responseBody)) {\n            debug('resuming response stream');\n            responseBody.resume();\n          }\n          else {\n            responseBuffers = responseBuffers || [];\n            if (typeof responseBody !== \"undefined\") {\n              debug('adding body to buffer list');\n              responseBuffers.push(responseBody);\n            }\n\n            // Stream the response chunks one at a time.\n            timers.setImmediate(function emitChunk() {\n              var chunk = responseBuffers.shift();\n\n              if (chunk) {\n                debug('emitting response chunk');\n                response.push(chunk);\n                timers.setImmediate(emitChunk);\n              }\n              else {\n                debug('ending response stream');\n                response.push(null);\n                interceptor.scope.emit('replied', req, interceptor);\n              }\n            });\n          }\n        }\n      }\n    }\n  };\n\n  return req;\n}\n\nmodule.exports = RequestOverrider;\n","/home/travis/build/npmtest/node-npmtest-nock/nock/lib/delayed_body.js":"'use strict';\n\n/**\n * Creates a stream which becomes the response body of the interceptor when a\n * delay is set. The stream outputs the intended body and EOF after the delay.\n *\n * @param  {String|Buffer|Stream} body - the body to write/pipe out\n * @param  {Integer} ms - The delay in milliseconds\n * @constructor\n */\nmodule.exports = DelayedBody;\n\nvar Transform = require('stream').Transform;\nvar EventEmitter = require('events').EventEmitter;\nvar noop = function () {};\nvar util = require('util');\nvar common = require('./common');\n\nif (!Transform) {\n  // for barebones compatibility for node < 0.10\n  var FakeTransformStream = function () {\n    EventEmitter.call(this);\n  };\n  util.inherits(FakeTransformStream, EventEmitter);\n  FakeTransformStream.prototype.pause = noop;\n  FakeTransformStream.prototype.resume = noop;\n  FakeTransformStream.prototype.setEncoding = noop;\n  FakeTransformStream.prototype.write = function (chunk, encoding) {\n    var self = this;\n    process.nextTick(function () {\n      self.emit('data', chunk, encoding);\n    });\n  };\n  FakeTransformStream.prototype.end = function (chunk) {\n    var self = this;\n    if (chunk) {\n      self.write(chunk);\n    }\n    process.nextTick(function () {\n      self.emit('end');\n    });\n  };\n\n  Transform = FakeTransformStream;\n}\n\nfunction DelayedBody(ms, body) {\n  Transform.call(this);\n\n  var self = this;\n  var data = '';\n  var ended = false;\n\n  if (common.isStream(body)) {\n    body.on('data', function (chunk) {\n      data += Buffer.isBuffer(chunk) ? chunk.toString() : chunk;\n    });\n\n    body.once('end', function () {\n      ended = true;\n    });\n\n    body.resume();\n  }\n\n  setTimeout(function () {\n    if (common.isStream(body) && !ended) {\n      body.once('end', function () {\n        self.end(data);\n      });\n    } else {\n      self.end(data || body);\n    }\n  }, ms);\n}\nutil.inherits(DelayedBody, Transform);\n\nDelayedBody.prototype._transform = function (chunk, encoding, cb) {\n  this.push(chunk);\n  process.nextTick(cb);\n};","/home/travis/build/npmtest/node-npmtest-nock/nock/lib/socket.js":"'use strict';\n\nvar EventEmitter = require('events').EventEmitter;\nvar debug        = require('debug')('nock.socket');\nvar util = require('util');\n\nmodule.exports = Socket;\n\nfunction Socket(options) {\n  if (!(this instanceof Socket)) {\n    return new Socket(options);\n  }\n\n  EventEmitter.apply(this);\n\n  options = options || {};\n\n  if (options.proto === 'https') {\n    this.authorized = true;\n  }\n\n  this.writable = true;\n  this.readable = true;\n  this.destroyed = false;\n\n  this.setNoDelay = noop;\n  this.setKeepAlive = noop;\n  this.resume = noop;\n\n  // totalDelay that has already been applied to the current\n  // request/connection, timeout error will be generated if\n  // it is timed-out.\n  this.totalDelayMs = 0;\n  // Maximum allowed delay. Null means unlimited.\n  this.timeoutMs = null;\n}\nutil.inherits(Socket, EventEmitter);\n\nSocket.prototype.setTimeout = function setTimeout(timeoutMs, fn) {\n  this.timeoutMs = timeoutMs;\n  this.timeoutFunction = fn;\n};\n\nSocket.prototype.applyDelay = function applyDelay(delayMs) {\n  this.totalDelayMs += delayMs;\n\n  if (this.timeoutMs && this.totalDelayMs > this.timeoutMs) {\n    debug('socket timeout');\n    if (this.timeoutFunction) {\n      this.timeoutFunction();\n    }\n    else {\n      this.emit('timeout');\n    }\n  }\n\n};\n\nSocket.prototype.getPeerCertificate = function getPeerCertificate() {\n  return new Buffer((Math.random() * 10000 + Date.now()).toString()).toString('base64');\n};\n\nSocket.prototype.destroy = function destroy() {\n  this.destroyed = true;\n  this.readable = this.writable = false;\n};\n\nfunction noop() {}\n\n","/home/travis/build/npmtest/node-npmtest-nock/nock/lib/global_emitter.js":"var EventEmitter = require('events').EventEmitter\n\nmodule.exports = new EventEmitter();","/home/travis/build/npmtest/node-npmtest-nock/nock/lib/interceptor.js":"'use strict';\n\nvar mixin           = require('./mixin')\n    , matchBody       = require('./match_body')\n    , common          = require('./common')\n    , _               = require('lodash')\n    , debug           = require('debug')('nock.scope')\n    , stringify       = require('json-stringify-safe')\n    , util            = require('util')\n    , qs              = require('qs');\n\nvar fs;\n\ntry {\n    fs = require('fs');\n} catch(err) {\n    // do nothing, we're in the browser\n}\n\nmodule.exports = Interceptor;\n\nfunction Interceptor(scope, uri, method, requestBody, interceptorOptions) {\n    this.scope = scope;\n    this.interceptorMatchHeaders = [];\n    this.method = method.toUpperCase();\n    this.uri = uri;\n    this._key = this.method + ' ' + scope.basePath + scope.basePathname + (typeof uri === 'string' ? '' : '/') + uri;\n    this.basePath = this.scope.basePath;\n    this.path = (typeof uri === 'string') ? scope.basePathname + uri : uri;\n\n    this.baseUri = this.method + ' ' + scope.basePath + scope.basePathname;\n    this.options = interceptorOptions || {};\n    this.counter = 1;\n    this._requestBody = requestBody;\n\n    //  We use lower-case header field names throughout Nock.\n    this.reqheaders = common.headersFieldNamesToLowerCase((scope.scopeOptions && scope.scopeOptions.reqheaders) || {});\n    this.badheaders = common.headersFieldsArrayToLowerCase((scope.scopeOptions && scope.scopeOptions.badheaders) || []);\n\n\n    this.delayInMs = 0;\n    this.delayConnectionInMs = 0;\n\n    this.optional = false;\n}\n\nInterceptor.prototype.optionally = function optionally() {\n    this.optional = true;\n    return this;\n}\n\nInterceptor.prototype.replyWithError = function replyWithError(errorMessage) {\n    this.errorMessage = errorMessage;\n\n    _.defaults(this.options, this.scope.scopeOptions);\n\n    this.scope.add(this._key, this, this.scope, this.scopeOptions);\n    return this.scope;\n};\n\nInterceptor.prototype.reply = function reply(statusCode, body, rawHeaders) {\n    if (arguments.length <= 2 && _.isFunction(statusCode)) {\n        body = statusCode;\n        statusCode = 200;\n    }\n\n    this.statusCode = statusCode;\n\n    _.defaults(this.options, this.scope.scopeOptions);\n\n    // convert rawHeaders from Array to Object\n    var headers = common.headersArrayToObject(rawHeaders);\n\n    if (this.scope._defaultReplyHeaders) {\n        headers = headers || {};\n        headers = mixin(this.scope._defaultReplyHeaders, headers);\n    }\n\n    if (this.scope.date) {\n        headers = headers || {};\n        headers['date'] = this.scope.date.toUTCString();\n    }\n\n    if (headers !== undefined) {\n        this.rawHeaders = [];\n\n        // makes sure all keys in headers are in lower case\n        for (var key in headers) {\n            if (headers.hasOwnProperty(key)) {\n                this.rawHeaders.push(key);\n                this.rawHeaders.push(headers[key]);\n            }\n        }\n\n        //  We use lower-case headers throughout Nock.\n        this.headers = common.headersFieldNamesToLowerCase(headers);\n\n        debug('reply.headers:', this.headers);\n        debug('reply.rawHeaders:', this.rawHeaders);\n    }\n\n    //  If the content is not encoded we may need to transform the response body.\n    //  Otherwise we leave it as it is.\n    if (!common.isContentEncoded(this.headers)) {\n        if (body && typeof(body) !== 'string' &&\n            typeof(body) !== 'function' &&\n            !Buffer.isBuffer(body) &&\n            !common.isStream(body)) {\n            try {\n                body = stringify(body);\n                if (!this.headers) {\n                    this.headers = {};\n                }\n                if (!this.headers['content-type']) {\n                    this.headers['content-type'] = 'application/json';\n                }\n                if (this.scope.contentLen) {\n                    this.headers['content-length'] = body.length;\n                }\n            } catch(err) {\n                throw new Error('Error encoding response body into JSON');\n            }\n        }\n    }\n\n    this.body = body;\n\n    this.scope.add(this._key, this, this.scope, this.scopeOptions);\n    return this.scope;\n};\n\nInterceptor.prototype.replyWithFile = function replyWithFile(statusCode, filePath, headers) {\n    if (! fs) {\n        throw new Error('No fs');\n    }\n    var readStream = fs.createReadStream(filePath);\n    readStream.pause();\n    this.filePath = filePath;\n    return this.reply(statusCode, readStream, headers);\n};\n\n// Also match request headers\n// https://github.com/pgte/nock/issues/163\nInterceptor.prototype.reqheaderMatches = function reqheaderMatches(options, key) {\n    //  We don't try to match request headers if these weren't even specified in the request.\n    if (! options.headers) {\n        return true;\n    }\n\n    var reqHeader = this.reqheaders[key];\n    var header = options.headers[key];\n    if (header && (typeof header !== 'string') && header.toString) {\n        header = header.toString();\n    }\n\n    //  We skip 'host' header comparison unless it's available in both mock and actual request.\n    //  This because 'host' may get inserted by Nock itself and then get recorder.\n    //  NOTE: We use lower-case header field names throughout Nock.\n    if (key === 'host' &&\n        (_.isUndefined(header) ||\n        _.isUndefined(reqHeader)))\n    {\n        return true;\n    }\n\n    if (reqHeader && header) {\n        if (_.isFunction(reqHeader)) {\n            return reqHeader(header);\n        } else if (common.matchStringOrRegexp(header, reqHeader)) {\n            return true;\n        }\n    }\n\n    debug('request header field doesn\\'t match:', key, header, reqHeader);\n    return false;\n};\n\nInterceptor.prototype.match = function match(options, body, hostNameOnly) {\n    if (debug.enabled) {\n        debug('match %s, body = %s', stringify(options), stringify(body));\n    }\n\n    if (hostNameOnly) {\n        return options.hostname === this.scope.urlParts.hostname;\n    }\n\n    var method = (options.method || 'GET').toUpperCase()\n        , path = options.path\n        , matches\n        , matchKey\n        , proto = options.proto;\n\n    if (this.scope.transformPathFunction) {\n        path = this.scope.transformPathFunction(path);\n    }\n    if (typeof(body) !== 'string') {\n        body = body.toString();\n    }\n    if (this.scope.transformRequestBodyFunction) {\n        body = this.scope.transformRequestBodyFunction(body, this._requestBody);\n    }\n\n    var checkHeaders = function(header) {\n        if (_.isFunction(header.value)) {\n            return header.value(options.getHeader(header.name));\n        }\n        return common.matchStringOrRegexp(options.getHeader(header.name), header.value);\n    };\n\n    if (!this.scope.matchHeaders.every(checkHeaders) ||\n        !this.interceptorMatchHeaders.every(checkHeaders)) {\n        this.scope.logger('headers don\\'t match');\n        return false;\n    }\n\n    var reqHeadersMatch =\n        ! this.reqheaders ||\n        Object.keys(this.reqheaders).every(this.reqheaderMatches.bind(this, options));\n\n    if (!reqHeadersMatch) {\n        return false;\n    }\n\n    function reqheaderContains(header) {\n        return _.has(options.headers, header);\n    }\n\n    var reqContainsBadHeaders =\n        this.badheaders &&\n        _.some(this.badheaders, reqheaderContains);\n\n    if (reqContainsBadHeaders) {\n        return false;\n    }\n\n    //  If we have a filtered scope then we use it instead reconstructing\n    //  the scope from the request options (proto, host and port) as these\n    //  two won't necessarily match and we have to remove the scope that was\n    //  matched (vs. that was defined).\n    if (this.__nock_filteredScope) {\n        matchKey = this.__nock_filteredScope;\n    } else {\n        matchKey = proto + '://' + options.host;\n        if (\n            options.port && options.host.indexOf(':') < 0 &&\n            (options.port !== 80 || options.proto !== 'http') &&\n            (options.port !== 443 || options.proto !== 'https')\n        ) {\n            matchKey += \":\" + options.port;\n        }\n    }\n\n    // Match query strings when using query()\n    var matchQueries = true;\n    var queryIndex = -1;\n    var queryString;\n    var queries;\n\n    if (this.queries) {\n        queryIndex = path.indexOf('?');\n        queryString = (queryIndex !== -1) ? path.slice(queryIndex + 1) : '';\n        queries = qs.parse(queryString);\n\n        // Only check for query string matches if this.queries is an object\n        if (_.isObject(this.queries)) {\n\n            if(_.isFunction(this.queries)){\n                matchQueries = this.queries(queries);\n            }else {\n                // Make sure that you have an equal number of keys. We are\n                // looping through the passed query params and not the expected values\n                // if the user passes fewer query params than expected but all values\n                // match this will throw a false positive. Testing that the length of the\n                // passed query params is equal to the length of expected keys will prevent\n                // us from doing any value checking BEFORE we know if they have all the proper\n                // params\n                debug('this.queries: %j', this.queries);\n                debug('queries: %j', queries);\n                if (_.size(this.queries) !== _.size(queries)) {\n                    matchQueries = false;\n                } else {\n                    var self = this;\n                    _.forOwn(queries, function matchOneKeyVal(val, key) {\n                        var expVal = self.queries[key];\n                        var isMatch = true;\n                        if (val === undefined || expVal === undefined) {\n                        isMatch = false;\n                    } else if (expVal instanceof RegExp) {\n                      isMatch = common.matchStringOrRegexp(val, expVal);\n                    } else if (_.isArray(expVal) || _.isObject(expVal)) {\n                      isMatch = _.isEqual(val, expVal);\n                    } else {\n                      isMatch = common.matchStringOrRegexp(val, expVal);\n                    }\n                matchQueries = matchQueries && !!isMatch;\n                });\n                }\n                debug('matchQueries: %j', matchQueries);\n            }\n        }\n\n        // Remove the query string from the path\n        if(queryIndex !== -1) {\n            path = path.substr(0, queryIndex);\n        }\n    }\n\n    if (typeof this.uri === 'function') {\n        matches = matchQueries &&\n        method.toUpperCase() + ' ' + proto + '://' + options.host === this.baseUri &&\n        this.uri.call(this, path);\n    } else {\n        matches = method === this.method &&\n        common.matchStringOrRegexp(matchKey, this.basePath) &&\n        common.matchStringOrRegexp(path, this.path) &&\n        matchQueries;\n    }\n\n    // special logger for query()\n    if (queryIndex !== -1) {\n        this.scope.logger('matching ' + matchKey + '?' + queryString + ' to ' + this._key +\n        ' with query(' + stringify(this.queries) + '): ' + matches);\n    } else {\n        this.scope.logger('matching ' + matchKey + ' to ' + this._key + ': ' + matches);\n    }\n\n    if (matches) {\n        matches = (matchBody.call(options, this._requestBody, body));\n        if (!matches) {\n            this.scope.logger('bodies don\\'t match: \\n', this._requestBody, '\\n', body);\n        }\n    }\n\n    return matches;\n};\n\nInterceptor.prototype.matchIndependentOfBody = function matchIndependentOfBody(options) {\n    var method = (options.method || 'GET').toUpperCase()\n        , path = options.path\n        , proto = options.proto;\n\n    if (this.scope.transformPathFunction) {\n        path = this.scope.transformPathFunction(path);\n    }\n\n    var checkHeaders = function(header) {\n        return options.getHeader && common.matchStringOrRegexp(options.getHeader(header.name), header.value);\n    };\n\n    if (!this.scope.matchHeaders.every(checkHeaders) ||\n        !this.interceptorMatchHeaders.every(checkHeaders)) {\n        return false;\n    }\n\n    var matchKey = method + ' ' + proto + '://' + options.host + path;\n    return this._key === matchKey;\n};\n\nInterceptor.prototype.filteringPath = function filteringPath() {\n    if (_.isFunction(arguments[0])) {\n        this.scope.transformFunction = arguments[0];\n    }\n    return this;\n};\n\nInterceptor.prototype.discard = function discard() {\n    if ((this.scope.shouldPersist() || this.counter > 0) && this.filePath) {\n        this.body = fs.createReadStream(this.filePath);\n        this.body.pause();\n    }\n\n    if (!this.scope.shouldPersist() && this.counter < 1) {\n        this.scope.remove(this._key, this);\n    }\n};\n\nInterceptor.prototype.matchHeader = function matchHeader(name, value) {\n    this.interceptorMatchHeaders.push({ name: name, value: value });\n    return this;\n};\n\nInterceptor.prototype.basicAuth = function basicAuth(options) {\n    var username = options['user'];\n    var password = options['pass'] || '';\n    var name = 'authorization';\n    var value = 'Basic ' + new Buffer(username + ':' + password).toString('base64');\n    this.interceptorMatchHeaders.push({ name: name, value: value });\n    return this;\n};\n\n/**\n * Set query strings for the interceptor\n * @name query\n * @param Object Object of query string name,values (accepts regexp values)\n * @public\n * @example\n * // Will match 'http://zombo.com/?q=t'\n * nock('http://zombo.com').get('/').query({q: 't'});\n */\nInterceptor.prototype.query = function query(queries) {\n    this.queries = this.queries || {};\n    // Allow all query strings to match this route\n    if (queries === true) {\n        this.queries = queries;\n    }\n\n    if(_.isFunction(queries)){\n        this.queries = queries;\n        return this;\n    }\n\n    for (var q in queries) {\n        if (_.isUndefined(this.queries[q])) {\n            var value = queries[q];\n            var formatedPair = common.formatQueryValue(q, value, this.scope.scopeOptions);\n            this.queries[formatedPair[0]] = formatedPair[1];\n        }\n    }\n\n    return this;\n};\n\n/**\n * Set number of times will repeat the interceptor\n * @name times\n * @param Integer Number of times to repeat (should be > 0)\n * @public\n * @example\n * // Will repeat mock 5 times for same king of request\n * nock('http://zombo.com).get('/').times(5).reply(200, 'Ok');\n */\nInterceptor.prototype.times = function times(newCounter) {\n    if (newCounter < 1) {\n        return this;\n    }\n\n    this.counter = newCounter;\n\n    return this;\n};\n\n/**\n * An sugar syntax for times(1)\n * @name once\n * @see {@link times}\n * @public\n * @example\n * nock('http://zombo.com).get('/').once.reply(200, 'Ok');\n */\nInterceptor.prototype.once = function once() {\n    return this.times(1);\n};\n\n/**\n * An sugar syntax for times(2)\n * @name twice\n * @see {@link times}\n * @public\n * @example\n * nock('http://zombo.com).get('/').twice.reply(200, 'Ok');\n */\nInterceptor.prototype.twice = function twice() {\n    return this.times(2);\n};\n\n/**\n * An sugar syntax for times(3).\n * @name thrice\n * @see {@link times}\n * @public\n * @example\n * nock('http://zombo.com).get('/').thrice.reply(200, 'Ok');\n */\nInterceptor.prototype.thrice = function thrice() {\n    return this.times(3);\n};\n\n/**\n * Delay the response by a certain number of ms.\n *\n * @param {(integer|object)} opts - Number of milliseconds to wait, or an object\n * @param {integer} [opts.head] - Number of milliseconds to wait before response is sent\n * @param {integer} [opts.body] - Number of milliseconds to wait before response body is sent\n * @return {interceptor} - the current interceptor for chaining\n */\nInterceptor.prototype.delay = function delay(opts) {\n    var headDelay = 0;\n    var bodyDelay = 0;\n    if (_.isNumber(opts)) {\n        headDelay = opts;\n    } else if (_.isObject(opts)) {\n        headDelay = opts.head || 0;\n        bodyDelay = opts.body || 0;\n    } else {\n        throw new Error(\"Unexpected input opts\" + opts);\n    }\n\n    return this.delayConnection(headDelay)\n        .delayBody(bodyDelay);\n};\n\n/**\n * Delay the response body by a certain number of ms.\n *\n * @param {integer} ms - Number of milliseconds to wait before response is sent\n * @return {interceptor} - the current interceptor for chaining\n */\nInterceptor.prototype.delayBody = function delayBody(ms) {\n    this.delayInMs += ms;\n    return this;\n};\n\n/**\n * Delay the connection by a certain number of ms.\n *\n * @param  {integer} ms - Number of milliseconds to wait\n * @return {interceptor} - the current interceptor for chaining\n */\nInterceptor.prototype.delayConnection = function delayConnection(ms) {\n    this.delayConnectionInMs += ms;\n    return this;\n};\n\nInterceptor.prototype.getTotalDelay =function getTotalDelay() {\n    return this.delayInMs + this.delayConnectionInMs;\n};\n\n/**\n * Make the socket idle for a certain number of ms (simulated).\n *\n * @param  {integer} ms - Number of milliseconds to wait\n * @return {interceptor} - the current interceptor for chaining\n */\nInterceptor.prototype.socketDelay = function socketDelay(ms) {\n    this.socketDelayInMs = ms;\n    return this;\n};\n","/home/travis/build/npmtest/node-npmtest-nock/nock/lib/mixin.js":"'use strict';\nvar _ = require(\"lodash\");\n\nfunction mixin(a, b) {\n\tif (! a) { a = {}; }\n\tif (! b) {b = {}; }\n\ta = _.cloneDeep(a);\n\tfor(var prop in b) {\n\t\ta[prop] = b[prop];\n\t}\n\treturn a;\n}\n\nmodule.exports = mixin;\n","/home/travis/build/npmtest/node-npmtest-nock/nock/lib/match_body.js":"'use strict';\n\nvar deepEqual = require('deep-equal');\nvar qs = require('querystring');\n\nmodule.exports =\nfunction matchBody(spec, body) {\n  if (typeof spec === 'undefined') {\n    return true;\n  }\n  var options = this || {};\n\n  if (Buffer.isBuffer(body)) {\n    body = body.toString();\n  }\n\n  var contentType = options.headers && (options.headers['Content-Type'] ||\n                                        options.headers['content-type']);\n\n  var isMultipart = contentType && contentType.toString().match(/multipart/);\n\n  //strip line endings from both so that we get a match no matter what OS we are running on\n  //if Content-Type does not contains 'multipart'\n  if (!isMultipart && typeof body === \"string\") {\n    body = body.replace(/\\r?\\n|\\r/g, '');\n  }\n\n  if (spec instanceof RegExp) {\n    return body.match(spec);\n  }\n\n  if (!isMultipart && typeof spec === \"string\") {\n    spec = spec.replace(/\\r?\\n|\\r/g, '');\n  }\n\n  // try to transform body to json\n  var json;\n  if (typeof spec === 'object' || typeof spec === 'function') {\n    try { json = JSON.parse(body);} catch(err) {}\n    if (json !== undefined) {\n      body = json;\n    } else {\n      if (contentType && contentType.toString().match(/application\\/x-www-form-urlencoded/)) {\n        body = qs.parse(body);\n      }\n    }\n  }\n\n  if (typeof spec === \"function\") {\n    return spec.call(this, body);\n  }\n\n  return deepEqualExtended(spec, body);\n};\n\nfunction deepEqualExtended(spec, body) {\n  if (spec && spec.constructor === RegExp) {\n    return spec.test(body);\n  }\n  if (spec && (spec.constructor === Object || spec.constructor === Array) && body) {\n    var keys = Object.keys(spec);\n    for (var i = 0; i < keys.length; i++) {\n      if (!deepEqualExtended(spec[keys[i]], body[keys[i]])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return deepEqual(spec, body, { strict: true });\n}\n","/home/travis/build/npmtest/node-npmtest-nock/nock/lib/scope.js":"/* jshint strict:false */\n/**\n * @module nock/scope\n */\nvar globalIntercept = require('./intercept')\n  , common          = require('./common')\n  , assert          = require('assert')\n  , url             = require('url')\n  , _               = require('lodash')\n  , debug           = require('debug')('nock.scope')\n  , stringify       = require('json-stringify-safe')\n  , EventEmitter    = require('events').EventEmitter\n  , extend          = require('util')._extend\n  , globalEmitter   = require('./global_emitter')\n  , util            = require('util')\n  , Interceptor     = require('./interceptor') ;\n\nvar fs;\n\ntry {\n  fs = require('fs');\n} catch(err) {\n  // do nothing, we're in the browser\n}\n\nfunction startScope(basePath, options) {\n  return new Scope(basePath, options);\n}\n\nfunction Scope(basePath, options) {\n  if (!(this instanceof Scope)) {\n    return new Scope(basePath, options);\n  }\n\n  EventEmitter.apply(this);\n  this.keyedInterceptors = {};\n  this.interceptors = [];\n  this.transformPathFunction = null;\n  this.transformRequestBodyFunction = null;\n  this.matchHeaders = [];\n  this.logger = debug;\n  this.scopeOptions = options || {};\n  this.urlParts = {};\n  this._persist = false;\n  this.contentLen = false;\n  this.date = null;\n  this.basePath = basePath;\n  this.basePathname = '';\n  this.port = null;\n\n  if (!(basePath instanceof RegExp)) {\n    this.urlParts = url.parse(basePath);\n    this.port = this.urlParts.port || ((this.urlParts.protocol === 'http:') ? 80 : 443);\n    this.basePathname = this.urlParts.pathname.replace(/\\/$/, '');\n    this.basePath = this.urlParts.protocol + '//' + this.urlParts.hostname + ':' + this.port;\n  }\n}\n\nutil.inherits(Scope, EventEmitter);\n\nScope.prototype.add = function add(key, interceptor, scope) {\n  if (! this.keyedInterceptors.hasOwnProperty(key)) {\n    this.keyedInterceptors[key] = [];\n  }\n  this.keyedInterceptors[key].push(interceptor);\n  globalIntercept(this.basePath,\n      interceptor,\n      this,\n      this.scopeOptions,\n      this.urlParts.hostname);\n};\n\nScope.prototype.remove = function remove(key, interceptor) {\n  if (this._persist) {\n    return;\n  }\n  var arr = this.keyedInterceptors[key];\n  if (arr) {\n    arr.splice(arr.indexOf(interceptor), 1);\n    if (arr.length === 0) {\n      delete this.keyedInterceptors[key];\n    }\n  }\n};\n\nScope.prototype.intercept = function intercept(uri, method, requestBody, interceptorOptions) {\n  var ic = new Interceptor(this, uri, method, requestBody, interceptorOptions);\n\n  this.interceptors.push(ic);\n  return ic;\n};\n\nScope.prototype.get = function get(uri, requestBody, options) {\n  return this.intercept(uri, 'GET', requestBody, options);\n};\n\nScope.prototype.post = function post(uri, requestBody, options) {\n  return this.intercept(uri, 'POST', requestBody, options);\n};\n\nScope.prototype.put = function put(uri, requestBody, options) {\n  return this.intercept(uri, 'PUT', requestBody, options);\n};\n\nScope.prototype.head = function head(uri, requestBody, options) {\n  return this.intercept(uri, 'HEAD', requestBody, options);\n};\n\nScope.prototype.patch = function patch(uri, requestBody, options) {\n  return this.intercept(uri, 'PATCH', requestBody, options);\n};\n\nScope.prototype.merge = function merge(uri, requestBody, options) {\n  return this.intercept(uri, 'MERGE', requestBody, options);\n};\n\nScope.prototype.delete = function _delete(uri, requestBody, options) {\n  return this.intercept(uri, 'DELETE', requestBody, options);\n};\n\nScope.prototype.options = function _options(uri, requestBody, options) {\n  return this.intercept(uri, 'OPTIONS', requestBody, options);\n};\n\nScope.prototype.pendingMocks = function pendingMocks() {\n  var self = this;\n\n  var pendingInterceptorKeys = Object.keys(this.keyedInterceptors).filter(function (key) {\n    var interceptorList = self.keyedInterceptors[key];\n    var pendingInterceptors = interceptorList.filter(function (interceptor) {\n      // TODO: This assumes that completed mocks are removed from the keyedInterceptors list\n      // (when persistence is off). We should change that (and this) in future.\n      var persistedAndUsed = self._persist && interceptor.interceptionCounter > 0;\n      return !persistedAndUsed && !interceptor.optional;\n    });\n    return pendingInterceptors.length > 0;\n  });\n\n  return pendingInterceptorKeys;\n};\n\n// Returns all keyedInterceptors that are active.\n// This incomplete interceptors, persisted but complete interceptors, and\n// optional interceptors, but not non-persisted and completed interceptors.\nScope.prototype.activeMocks = function activeMocks() {\n  return Object.keys(this.keyedInterceptors);\n}\n\nScope.prototype.isDone = function isDone() {\n  var self = this;\n  // if nock is turned off, it always says it's done\n  if (! globalIntercept.isOn()) { return true; }\n\n  return this.pendingMocks().length === 0;\n};\n\nScope.prototype.done = function done() {\n  assert.ok(this.isDone(), \"Mocks not yet satisfied:\\n\" + this.pendingMocks().join(\"\\n\"));\n};\n\nScope.prototype.buildFilter = function buildFilter() {\n  var filteringArguments = arguments;\n\n  if (arguments[0] instanceof RegExp) {\n    return function(candidate) {\n      if (candidate) {\n        candidate = candidate.replace(filteringArguments[0], filteringArguments[1]);\n      }\n      return candidate;\n    };\n  } else if (_.isFunction(arguments[0])) {\n    return arguments[0];\n  }\n};\n\nScope.prototype.filteringPath = function filteringPath() {\n  this.transformPathFunction = this.buildFilter.apply(this, arguments);\n  if (!this.transformPathFunction) {\n    throw new Error('Invalid arguments: filtering path should be a function or a regular expression');\n  }\n  return this;\n};\n\nScope.prototype.filteringRequestBody = function filteringRequestBody() {\n  this.transformRequestBodyFunction = this.buildFilter.apply(this, arguments);\n  if (!this.transformRequestBodyFunction) {\n    throw new Error('Invalid arguments: filtering request body should be a function or a regular expression');\n  }\n  return this;\n};\n\nScope.prototype.matchHeader = function matchHeader(name, value) {\n  //  We use lower-case header field names throughout Nock.\n  this.matchHeaders.push({ name: name.toLowerCase(), value: value });\n  return this;\n};\n\nScope.prototype.defaultReplyHeaders = function defaultReplyHeaders(headers) {\n  this._defaultReplyHeaders = common.headersFieldNamesToLowerCase(headers);\n  return this;\n};\n\nScope.prototype.log = function log(newLogger) {\n  this.logger = newLogger;\n  return this;\n};\n\nScope.prototype.persist = function persist() {\n  this._persist = true;\n  return this;\n};\n\nScope.prototype.shouldPersist = function shouldPersist() {\n  return this._persist;\n};\n\nScope.prototype.replyContentLength = function replyContentLength() {\n  this.contentLen = true;\n  return this;\n};\n\nScope.prototype.replyDate = function replyDate(d) {\n  this.date = d || new Date();\n  return this;\n};\n\n\n\n\nfunction cleanAll() {\n  globalIntercept.removeAll();\n  return module.exports;\n}\n\nfunction loadDefs(path) {\n  if (! fs) {\n    throw new Error('No fs');\n  }\n\n  var contents = fs.readFileSync(path);\n  return JSON.parse(contents);\n}\n\nfunction load(path) {\n  return define(loadDefs(path));\n}\n\nfunction getStatusFromDefinition(nockDef) {\n  //  Backward compatibility for when `status` was encoded as string in `reply`.\n  if (!_.isUndefined(nockDef.reply)) {\n    //  Try parsing `reply` property.\n    var parsedReply = parseInt(nockDef.reply, 10);\n    if (_.isNumber(parsedReply)) {\n      return parsedReply;\n    }\n  }\n\n  var DEFAULT_STATUS_OK = 200;\n  return nockDef.status || DEFAULT_STATUS_OK;\n}\n\nfunction getScopeFromDefinition(nockDef) {\n\n  //  Backward compatibility for when `port` was part of definition.\n  if (!_.isUndefined(nockDef.port)) {\n    //  Include `port` into scope if it doesn't exist.\n    var options = url.parse(nockDef.scope);\n    if (_.isNull(options.port)) {\n      return nockDef.scope + ':' + nockDef.port;\n    } else {\n      if (parseInt(options.port) !== parseInt(nockDef.port)) {\n        throw new Error('Mismatched port numbers in scope and port properties of nock definition.');\n      }\n    }\n  }\n\n  return nockDef.scope;\n}\n\nfunction tryJsonParse(string) {\n  try {\n    return JSON.parse(string);\n  } catch(err) {\n    return string;\n  }\n}\n\nfunction define(nockDefs) {\n\n  var nocks     = [];\n\n  nockDefs.forEach(function(nockDef) {\n\n    var nscope     = getScopeFromDefinition(nockDef)\n      , npath      = nockDef.path\n      , method     = nockDef.method.toLowerCase() || \"get\"\n      , status     = getStatusFromDefinition(nockDef)\n      , rawHeaders = nockDef.rawHeaders || []\n      , reqheaders = nockDef.reqheaders || {}\n      , body       = nockDef.body       || ''\n      , options    = nockDef.options    || {};\n\n    //  We use request headers for both filtering (see below) and mocking.\n    //  Here we are setting up mocked request headers but we don't want to\n    //  be changing the user's options object so we clone it first.\n    options = _.clone(options) || {};\n    options.reqheaders = reqheaders;\n\n    //  Response is not always JSON as it could be a string or binary data or\n    //  even an array of binary buffers (e.g. when content is enconded)\n    var response;\n    if (!nockDef.response) {\n      response = '';\n    } else {\n      response = _.isString(nockDef.response) ? tryJsonParse(nockDef.response) : nockDef.response;\n    }\n\n    var nock;\n    if (body===\"*\") {\n      nock = startScope(nscope, options).filteringRequestBody(function() {\n        return \"*\";\n      })[method](npath, \"*\").reply(status, response, rawHeaders);\n    } else {\n      nock = startScope(nscope, options);\n      //  If request headers were specified filter by them.\n      if (_.size(reqheaders) > 0) {\n        for (var k in reqheaders) {\n          nock.matchHeader(k, reqheaders[k]);\n        }\n      }\n      if (nockDef.filteringRequestBody) {\n        nock.filteringRequestBody(nockDef.filteringRequestBody);\n      }\n      nock.intercept(npath, method, body).reply(status, response, rawHeaders);\n    }\n\n    nocks.push(nock);\n\n  });\n\n  return nocks;\n}\n\nmodule.exports = extend(startScope, {\n  cleanAll: cleanAll,\n  activate: globalIntercept.activate,\n  isActive: globalIntercept.isActive,\n  isDone: globalIntercept.isDone,\n  pendingMocks: globalIntercept.pendingMocks,\n  activeMocks: globalIntercept.activeMocks,\n  removeInterceptor: globalIntercept.removeInterceptor,\n  disableNetConnect: globalIntercept.disableNetConnect,\n  enableNetConnect: globalIntercept.enableNetConnect,\n  load: load,\n  loadDefs: loadDefs,\n  define: define,\n  emitter: globalEmitter,\n});\n","/home/travis/build/npmtest/node-npmtest-nock/nock/lib/back.js":"'use strict';\n\nvar _ = require('lodash');\nvar nock = require('./scope');\nvar recorder = require('./recorder');\n\nvar format = require('util').format;\nvar path = require('path');\nvar expect = require('chai').expect;\nvar debug = require('debug')('nock.back');\n\nvar _mode = null;\n\nvar fs;\n\ntry {\n  fs = require('fs');\n} catch(err) {\n  // do nothing, probably in browser\n}\n\nvar mkdirp;\ntry {\n  mkdirp = require('mkdirp');\n} catch(err) {\n  // do nothing, probably in browser\n}\n\n\n/**\n * nock the current function with the fixture given\n *\n * @param {string}   fixtureName  - the name of the fixture, e.x. 'foo.json'\n * @param {object}   options      - [optional], extra options for nock with, e.x. { assert: true }\n * @param {function} nockedFn     - the callback function to be executed with the given fixture being loaded,\n *                                  the function will be called with { scopes: loaded_nocks || [] } set as this\n *\n *\n * List of options:\n *\n * @param {function} before       - a preprocessing function, gets called before nock.define\n * @param {function} after        - a postprocessing function, gets called after nock.define\n * @param {function} afterRecord  - a postprocessing function, gets called after recording. Is passed the array\n *                                  of scopes recorded and should return the array scopes to save to the fixture\n * @param {function} recorder     - custom options to pass to the recorder\n *\n */\nfunction Back (fixtureName, options, nockedFn) {\n  if(!Back.fixtures) {\n    throw new Error(  'Back requires nock.back.fixtures to be set\\n' +\n                      'Ex:\\n' +\n                      '\\trequire(nock).back.fixtures = \\'/path/to/fixures/\\'');\n  }\n\n  if( arguments.length === 2 ) {\n    nockedFn = options;\n    options = {};\n  }\n\n  _mode.setup();\n\n  var fixture = path.join(Back.fixtures, fixtureName)\n    , context = _mode.start(fixture, options);\n\n\n  var nockDone = function () {\n    _mode.finish(fixture, options, context);\n  };\n\n  debug('context:', context);\n\n  nockedFn.call(context, nockDone);\n}\n\n\n\n\n/*******************************************************************************\n*                                    Modes                                     *\n*******************************************************************************/\n\n\nvar wild = {\n\n\n  setup: function () {\n    nock.cleanAll();\n    recorder.restore();\n    nock.activate();\n    nock.enableNetConnect();\n  },\n\n\n  start: function () {\n    return load(); //don't load anything but get correct context\n  },\n\n\n  finish: function () {\n    //nothing to do\n  }\n\n\n};\n\n\n\n\nvar dryrun = {\n\n\n  setup: function () {\n    recorder.restore();\n    nock.cleanAll();\n    nock.activate();\n    //  We have to explicitly enable net connectivity as by default it's off.\n    nock.enableNetConnect();\n  },\n\n\n  start: function (fixture, options) {\n    var contexts = load(fixture, options);\n\n    nock.enableNetConnect();\n    return contexts;\n  },\n\n\n  finish: function () {\n    //nothing to do\n  }\n\n\n};\n\n\n\n\nvar record = {\n\n\n  setup: function () {\n    recorder.restore();\n    recorder.clear();\n    nock.cleanAll();\n    nock.activate();\n    nock.disableNetConnect();\n  },\n\n\n  start: function (fixture, options) {\n    if (! fs) {\n      throw new Error('no fs');\n    }\n    var context = load(fixture, options);\n\n    if( !context.isLoaded ) {\n      recorder.record(_.assign({\n        dont_print: true,\n        output_objects: true\n      }, options && options.recorder));\n\n      context.isRecording = true;\n    }\n\n    return context;\n  },\n\n\n  finish: function (fixture, options, context) {\n    if( context.isRecording ) {\n      var outputs = recorder.outputs();\n\n      if( typeof options.afterRecord === 'function' ) {\n        outputs = options.afterRecord(outputs);\n      }\n\n      outputs = JSON.stringify(outputs, null, 4);\n      debug('recorder outputs:', outputs);\n\n      mkdirp.sync(path.dirname(fixture));\n      fs.writeFileSync(fixture, outputs);\n    }\n  }\n\n\n};\n\n\n\n\nvar lockdown = {\n\n\n  setup: function () {\n    recorder.restore();\n    recorder.clear();\n    nock.cleanAll();\n    nock.activate();\n    nock.disableNetConnect();\n  },\n\n\n  start: function (fixture, options) {\n    return load(fixture, options);\n  },\n\n\n  finish: function () {\n    //nothing to do\n  }\n\n\n};\n\n\n\n\nfunction load (fixture, options) {\n  var context = {\n    scopes : [],\n    assertScopesFinished: function () {\n      assertScopes(this.scopes, fixture);\n    }\n  };\n\n  if( fixture && fixtureExists(fixture) ) {\n    var scopes = nock.loadDefs(fixture);\n    applyHook(scopes, options.before);\n\n    scopes = nock.define(scopes);\n    applyHook(scopes, options.after);\n\n    context.scopes = scopes;\n    context.isLoaded = true;\n  }\n\n\n  return context;\n}\n\n\n\n\nfunction applyHook(scopes, fn) {\n  if( !fn ) {\n    return;\n  }\n\n  if( typeof fn !== 'function' ) {\n    throw new Error ('processing hooks must be a function');\n  }\n\n  scopes.forEach(fn);\n}\n\n\n\n\nfunction fixtureExists(fixture) {\n  if (! fs) {\n    throw new Error('no fs');\n  }\n\n  return fs.existsSync(fixture);\n}\n\n\n\n\nfunction assertScopes (scopes, fixture) {\n  scopes.forEach(function (scope) {\n    expect( scope.isDone() )\n    .to.be.equal(\n      true,\n      format('%j was not used, consider removing %s to rerecord fixture', scope.pendingMocks(), fixture)\n    );\n  });\n}\n\n\n\n\nvar Modes = {\n\n  wild: wild, //all requests go out to the internet, dont replay anything, doesnt record anything\n\n  dryrun: dryrun, //use recorded nocks, allow http calls, doesnt record anything, useful for writing new tests (default)\n\n  record: record, //use recorded nocks, record new nocks\n\n  lockdown: lockdown, //use recorded nocks, disables all http calls even when not nocked, doesnt record\n\n};\n\n\n\n\n\nBack.setMode = function(mode) {\n  if( !Modes.hasOwnProperty(mode) ) {\n    throw new Error ('some usage error');\n  }\n\n  Back.currentMode = mode;\n  debug('New nock back mode:', Back.currentMode);\n\n  _mode = Modes[mode];\n  _mode.setup();\n};\n\n\n\n\nBack.fixtures = null;\nBack.currentMode = null;\nBack.setMode(process.env.NOCK_BACK_MODE || 'dryrun');\n\nmodule.exports = exports = Back;\n"}